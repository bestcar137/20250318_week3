package CH_code.ch05;// ===============================================================
// 📘 문제 요약:
// ===============================================================
// 사용자는 먼저 스택 저장 용량(정수)을 입력한 뒤,
// 문자열을 계속 입력합니다.
//
// 문자열이 "그만"일 경우 입력을 종료하고,
// 저장된 모든 문자열을 역순(LIFO)으로 출력합니다.
//
// 저장 용량을 초과하면 "스택이 꽉 차서 푸시 불가!"를 출력합니다.
//
// 📌 조건 요약:
// - push 실패: 스택이 꽉 차면 메시지 출력
// - 종료 조건: "그만" 입력
// - 출력: "스택에 저장된 모든 문자열 팝 :" + 저장된 문자열들
// ===============================================================

import java.util.Scanner; // 사용자 입력을 받을 수 있게 해주는 도구 (java.util 패키지에 있음)

// ===============================================================
// 🚀 Main 클래스 (프로그램 시작 지점)
// ===============================================================
public class HW5_4 {

    // main(): 자바 프로그램이 시작되는 진입점 메서드
    // static: 객체를 생성하지 않고 실행 가능
    // void: 값을 반환하지 않음
    public static void main(String[] args) {
        // StackApp 클래스의 run() 메서드를 호출 → 실제 기능 실행
        StackApp.run();
    }
}

// ===============================================================
// 📦 Stack 인터페이스: 스택의 동작을 정의한 틀
// ===============================================================
interface Stack {

    // 현재 스택에 저장된 요소의 개수를 반환
    int length();

    // 스택의 전체 저장 용량 반환
    int capacity();

    // 스택에서 마지막에 추가된 요소를 꺼냄
    String pop();

    // 스택에 새 값을 넣음 (push)
    // 성공 시 true, 실패 시 false 반환
    boolean push(String val);
}

// ===============================================================
// 📦 StringStack 클래스: Stack 인터페이스를 구현한 클래스
// 문자열을 배열에 저장하여 스택을 직접 구현
// ===============================================================
class StringStack implements Stack {

    // 문자열들을 저장할 배열
    // private → 외부에서 직접 접근 불가능 (캡슐화 원칙)
    private String[] arr;

    // 스택의 현재 top 위치 (실제 저장된 문자열 개수)
    // 배열 인덱스처럼 쓰이며, 다음에 저장할 위치를 가리킴
    private int top = 0;

    // 생성자: 사용자가 지정한 크기의 배열 생성
    public StringStack(int capacity) {
        arr = new String[capacity];
    }

    // 현재 저장된 문자열 수 반환
    public int length() {
        return top;
    }

    // 전체 배열 크기 반환 → 스택 최대 저장 가능 개수
    public int capacity() {
        return arr.length;
    }

    // 문자열 꺼내기 (후입선출 LIFO 구조)
    public String pop() {
        if (top == 0) return null; // 아무것도 없으면 null 반환
        return arr[--top]; // top 하나 줄이고 그 위치의 문자열 반환
    }

    // 문자열 저장하기 (push)
    public boolean push(String val) {
        if (top == arr.length) return false; // 스택이 꽉 찼으면 저장 불가
        arr[top++] = val; // 현재 top 위치에 저장 후 top 증가
        return true;
    }
}

// ===============================================================
// 🏃 StackApp 클래스: 실제 스택을 사용하여 입출력을 처리
// ===============================================================
class StackApp {

    // 정적 메서드 run(): Main에서 호출됨
    public static void run() {

        Scanner sc = new Scanner(System.in); // 입력을 받기 위한 Scanner 생성

        // 첫 줄: 저장 용량 입력 (예: 3)
        int size = Integer.parseInt(sc.nextLine()); // nextLine()으로 받고 정수로 변환

        // 입력받은 크기만큼 스택 생성
        StringStack stack = new StringStack(size);

        // 문자열 입력 반복
        while (true) {
            String input = sc.nextLine(); // 한 줄 입력

            if (input.equals("그만")) break; // 종료 조건

            // 입력한 문자열을 스택에 저장 시도
            if (!stack.push(input)) {
                // 실패 시(스택 꽉 참) 경고 출력
                System.out.println("스택이 꽉 차서 푸시 불가!");
            }

            // 계속 입력을 받음 (문제 조건상 실패해도 종료 안 함)
        }

        // 입력이 종료되었으므로 저장된 모든 문자열을 꺼내서 출력
        System.out.print("스택에 저장된 모든 문자열 팝 :");

        // 스택이 비어있지 않은 동안 반복
        while (stack.length() > 0) {
            System.out.print(" " + stack.pop()); // 후입선출 순서로 출력
        }

        // 문제의 출력 조건에 따라 줄바꿈은 하지 않음
    }
}

/*
====================================================================
🧭 실행 흐름 정리 (순서도 느낌)
====================================================================

1. 프로그램 시작 → main() 실행
   └→ StackApp.run() 호출

2. run() 내부에서 실행 순서:
   ├─ Scanner 생성 (사용자 입력 대기)
   ├─ 스택 용량 입력 (예: 3)
   ├─ StringStack 객체 생성 (크기 3짜리 배열 기반 스택)

3. 입력 루프 시작:
   ├─ 사용자로부터 문자열 반복 입력 (nextLine)
   ├─ "그만" 입력 시 종료
   ├─ 입력한 문자열을 stack.push()
       ├─ 성공 시 스택에 저장
       └─ 실패 시 (스택 꽉 참) → "스택이 꽉 차서 푸시 불가!" 출력

4. 출력 단계:
   ├─ "스택에 저장된 모든 문자열 팝 :" 출력
   ├─ while 루프 → stack.pop()으로 하나씩 꺼내며 출력 (역순)
   └─ 출력은 공백으로 구분, 줄바꿈 없음

====================================================================
🧠 이 예제로 익히는 자바 개념 정리
====================================================================
- 📦 인터페이스: Stack 인터페이스 → 기능만 정의
- 🧱 구현 클래스: StringStack → 기능 직접 구현
- 💡 캡슐화: private 필드로 정보 은닉
- 🛠 배열 기반 스택 구현
- 🔁 반복문 + 조건문 활용
- ✨ LIFO 구조 이해 (후입선출)
- ✍ nextLine()과 nextInt() 차이
- 💬 사용자 정의 메시지 처리 ("그만", 실패 메시지 등)

====================================================================
*/
