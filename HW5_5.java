// =========================================================
// 📘 문제 설명 요약:
// =========================================================
// 정수 2개와 연산자 1개를 입력받고, 해당 연산을 수행하는 프로그램을 작성한다.
// 연산자는 +, -, *, / 중 하나만 유효하다.
// - 연산자 외의 문자가 입력되면: "잘못된 연산자입니다."
// - 나눗셈에서 0으로 나누면: "계산할 수 없습니다."
// 각 연산은 Add, Sub, Mul, Div 클래스로 처리하며,
// 이들은 모두 공통 부모 클래스 Calc를 상속받는다.
//
// Calc 클래스에는 다음이 포함된다:
// - int 타입의 a, b 필드
// - void setValue(int a, int b) 메서드
// - int calculate() 추상 메서드
//
// =========================================================

import java.util.Scanner; // 사용자 입력을 받을 때 사용하는 Scanner 클래스

// =========================================================
// 🚀 Main 클래스: 프로그램 실행 시작점
// =========================================================
public class HW5_5 {

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in); // 사용자 입력을 받기 위한 Scanner 객체 생성

        int a = sc.nextInt();  // 첫 번째 정수 입력
        int b = sc.nextInt();  // 두 번째 정수 입력
        String op = sc.next(); // 연산자 입력: "+", "-", "*", "/" 중 하나

        Calc calc = null; // Calc 타입 참조 변수 선언 (실제 객체는 아래 switch에서 생성)

        // 입력된 연산자에 따라 해당 연산 클래스 객체 생성
        switch (op) {
            case "+":
                calc = new Add();
                break;
            case "-":
                calc = new Sub();
                break;
            case "*":
                calc = new Mul();
                break;
            case "/":
                if (b == 0) {
                    // 0으로 나누는 것은 수학적으로 불가능하므로 예외 처리
                    System.out.println("계산할 수 없습니다.");
                    return; // 프로그램 종료
                }
                calc = new Div();
                break;
            default:
                // 유효하지 않은 연산자 입력 시 에러 메시지 출력 후 종료
                System.out.println("잘못된 연산자입니다.");
                return;
        }

        // 피연산자 값을 연산 객체에 설정
        calc.setValue(a, b);

        // 실제 연산을 수행하고 결과 출력
        System.out.println(calc.calculate());
    }
}

// =========================================================
// 🧱 추상 클래스 Calc: 공통 속성과 기능 정의
// =========================================================
abstract class Calc {
    protected int a, b; // 피연산자: 자식 클래스에서 접근할 수 있도록 protected로 선언

    // 외부에서 a, b 값을 객체 내부에 저장하는 메서드
    public void setValue(int a, int b) {
        this.a = a; // this.a는 필드, a는 매개변수
        this.b = b;
    }

    // 추상 메서드: 실제 연산은 자식 클래스가 구현하도록 강제
    public abstract int calculate();
}

// =========================================================
// ➕ Add 클래스: 덧셈 구현
// =========================================================
class Add extends Calc {
    public int calculate() {
        return a + b; // 덧셈 결과 반환
    }
}

// =========================================================
// ➖ Sub 클래스: 뺄셈 구현
// =========================================================
class Sub extends Calc {
    public int calculate() {
        return a - b; // 뺄셈 결과 반환
    }
}

// =========================================================
// ✖ Mul 클래스: 곱셈 구현
// =========================================================
class Mul extends Calc {
    public int calculate() {
        return a * b; // 곱셈 결과 반환
    }
}

// =========================================================
// ➗ Div 클래스: 나눗셈 구현
// =========================================================
class Div extends Calc {
    public int calculate() {
        return a / b; // 나눗셈 결과 반환 (0 나누기는 Main에서 이미 처리)
    }
}

/*
============================================================
🧭 프로그램 실행 흐름 요약
============================================================

1. 사용자 입력:
   - 정수 2개 (a, b)
   - 연산자 1개 ("+", "-", "*", "/")

2. switch문을 통해 연산자 판단:
   - + → Add 객체 생성
   - - → Sub 객체 생성
   - * → Mul 객체 생성
   - / → (b == 0 이면 예외) Div 객체 생성
   - 그 외 → "잘못된 연산자입니다." 출력

3. setValue(a, b) 호출 → 객체 내부에 값 저장

4. calculate() 호출 → 연산 결과 리턴

5. 결과 출력

============================================================
📚 이 코드로 배우는 자바 개념
============================================================
- 추상 클래스(Abstract Class)와 추상 메서드
- 메서드 오버라이딩 (Override)
- protected 접근 제어자
- switch-case 조건 분기
- 다형성(Polymorphism): 부모 타입으로 자식 객체 제어
- 예외 상황 처리 흐름
- 객체지향 설계 구조: 클래스 분리, 확장 용이성
============================================================
*/
